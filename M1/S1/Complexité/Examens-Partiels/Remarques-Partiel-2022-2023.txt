Vous trouverez ici un corrigé du partiel. Celui-ci contient bien évidemment beaucoup plus d'éléments, d'explications et de commentaires qu'il n'était nécessaire d'en fournir pour obtenir la note maximale. Notez qu'il n'y avait aucune surprise concernant la forme du sujet, s'agissant d'une sorte de "clone" du sujet de partiel de l'an passé. Ceux parmi vous qui se sont exercés avec, mais seulement eux, ont pu s'en rendre compte et étaient donc bien préparés. Concernant les copies, parmi les erreurs (trop) fréquentes, ci-dessous vous trouverez un petit récapitulatif de ce qui a pu être relevé. 

Exercice 1. Si dans l'ensemble cet exercice a correctement été traité (c'est normal, il relève en fait d'un niveau de L1), on a pu relever parfois des "débordements" de tableau, l'absence d'initialisation des variables contrôlant les boucles, parfois de mise à jour de ces variables dans les boucles, ce qui constituent des erreurs qui ne doivent plus être commises fin de L1, voire en fin de 1er semestre en L1. Il faut aussi rappeler que la lecture du préambule du sujet était très importante. En effet, il était explicitement indiqué que les algorithmes devaient être présentés dans un pseudo-code sans qu'il existe la moindre ambiguïtés sur l'interprétation des instructions. Pour la complexité, souvent, pas d'évocation du pire des cas, ni de rappel que certaines instructions s'exécutent en temps constant. Parfois pas d'utilisation ni de la notation O, souvent pas de Θ, et pour rappel, quand on peut utiliser Θ, il ne faut pas utiliser O (qui relève de l'imprécision et c'est donc une erreur : un informaticien doit être précis !!!). Ces constats valent bien sûr aussi pour le traitement des question 3 et 4 de l'exercice 3.

Exercice 2. Certains ne semblent pas avoir compris ce qu'est une Machine de Turing Déterministe, malgré les rappels détaillés faits en cours, en TD voire aussi en TP. Petit détail, pour un mot de taille n en entrée, ce sont n+1 transitions qui sont à réaliser, et non n (mais ceci est juste un petit détail) et dans tous les cas, il fallait préciser avec arguments à l'appui, pourquoi la complexité était linéaire (avec la notation Θ). Et de même, bien justifier l'appartenance de ce langage à la classe P. 

Exercice 3. Le problème de graphe qui est traité ici est bien plus simple à comprendre que de nombreux problèmes que vous avez abordé en Licence (que ce soit en L2 ou en L3). On estime qu'au niveau M1, il ne doit plus y avoir de souci pour appréhender ce type de question. Parmi les problèmes rencontrés dans les différentes questions : 

Q1. Incompréhension trop fréquente de ce qu'est une instance particulière du problème traité. Souvent un minimum de rigueur n'est pas observé (plusieurs copies avec des graphes de 11, voire 10 arêtes alors qu'il en fallait précisément 12). 

Q2. Cela relevait d'une simple question de cours. Et le même type de question a été traité dans le TD3.

Q3. Une grande majorité des réponses se proposait juste de vérifier que les valeurs des éléments t[i] étaient inférieures à k... sans s'assurer que l'on doit avoir 1 ≤ t[i] ≤ k, pour tout élément t[i] du tableau (avec donc 1 ≤ i ≤ G.n), et surtout, qu'aucune parti Sj n'est vide (ce qui n'a que très rarement été vérifié). 

Q4., Q5 et Q7. Pas de commentaire. 

Pour conclure, comme vous êtes informaticiens, et donc a priori a minima programmeurs, il faut songer ici à la qualité de présentation du code, même, ou plutôt surtout, quand on écrit des algorithmes. Par ailleurs, il est toujours utile, pas seulement pour le correcteur, mais en fait souvent surtout pour le concepteur, de fournir des commentaires dans le code. Cela permet de mieux maîtriser la production de code car cela permet d'expliciter ce qu'une partie de code calcule. Enfin, lorsqu'un algorithme est écrit dans un "langage algorithmique" de base comme demandé et comme présenté dans les différents corrigés des TD, il n'est pas question d'utiliser des fonctionnalités spécifiques à tel ou tel langage de programmation, sauf à les préciser explicitement en commentaire.